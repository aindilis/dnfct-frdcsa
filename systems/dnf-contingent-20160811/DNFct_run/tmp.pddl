(define (domain blocks)
  (:requirements :typing)
  (:types block)
  (:predicates (on ?x - block ?y - block)
	       (ontable ?x - block)
	       (clear ?x - block)
	       (handempty)
	       (holding ?x - block)
  )
  (:action pick-up
    :parameters (?x - block)
    :effect
      (when (and (handempty) (clear ?x) (ontable ?x))
        (and (not (ontable ?x))
             (not (clear ?x))
             (not (handempty))
             (holding ?x))
      )
  )
  (:action put-down
    :parameters (?x - block)
    :effect (when (holding ?x) (and (not (holding ?x)) (clear ?x) (handempty) (ontable ?x)))
  )
  (:action stack
    :parameters (?x - block ?y - block)
    :effect
      (when (and (holding ?x) (clear ?y))
        (and (not (holding ?x))
             (not (clear ?y))
             (clear ?x)
             (handempty)
             (on ?x ?y))
      )
  )
  (:action unstack
    :parameters (?x - block ?y - block)
    :effect
      (when (and (handempty) (on ?x ?y) (clear ?x))
        (and (holding ?x)
             (clear ?y)
             (not (clear ?x))
             (not (handempty))
             (not (on ?x ?y)))
      )
   )
)
(define (problem b2)
  (:domain blocks)
  (:objects A B - block)
  (:init
    (and (oneof (handempty) (holding A) (holding B))          ; (holding ?x)
         (oneof (holding A) (clear A) (on B A))               ; (above A ?x)
         (oneof (holding A) (ontable A) (on A B))             ; (on A ?x)
         (oneof (holding B) (clear B) (on A B))               ; (above B ?x)
         (oneof (holding B) (ontable B) (on B A))             ; (on B ?x)

         (or (not (handempty)) (not (holding A)))
         (or (not (handempty)) (not (holding B)))
         (or (not (holding A)) (not (holding B)))

         (or (not (holding A)) (not (clear A)))
         (or (not (holding A)) (not (on B A)))
         (or (not (clear A)) (not (on B A)))

         (or (not (holding A)) (not (ontable A)))
         (or (not (holding A)) (not (on A B)))
         (or (not (ontable A)) (not (on A B)))

         (or (not (holding B)) (not (clear B)))
         (or (not (holding B)) (not (on A B)))
         (or (not (clear B)) (not (on A B)))

         (or (not (holding B)) (not (clear B)))
         (or (not (holding B)) (not (on A B)))
         (or (not (clear B)) (not (on A B)))

         (or (not (on A B)) (not (on B A)))                   ; cycles
    )
  )
  (:goal (and (ontable A) (on B A)))
)
